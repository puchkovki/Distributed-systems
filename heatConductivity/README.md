# **Одномерное уравнение теплопроводности**

## **Задача** 

Решить одномерное уравнение теплопроводности при заданных граничных условиях и
начальном распределении температуры $f(x)$. 

$`\frac{\partial u}{\partial t} = \frac{\partial^2 u}{\partial x^2}, x \in[0, 1]`$
$`u(x, 0) = f(x), u(0, t) = u_1, u(1, t) = u_{\text{r}}`$

Представим, что значально температура в стержне длины `L` была распределена по
закону $f(x)$. Далее к его краям приложили два нагретых бруска с температурами
`Temperature_1` и `Temperature_2` соответственно. По закону теплопроводности
Фурье начал происходить теплообмен стержня с брусками. В задаче используется
явный схема: $u_{m}^{n + 1} = u_m^n + \frac{\tau}{h^2}(u_{m - 1}^n - 2u_m^n +$
$u_{m + 1}^{n})$.

 Найти $u(x, T)$.

Входные параметры:
1. Момент времени `Time`, в который требуется узнать распределение температуры.
2. Число разбиения длины стержня `M`.

Результат: распределение температуры в стержне в заданный момент времени.

### **Требования**
1. Распараллелить программу, используя среду MPI (обязательно использовать
вызовы `MPI_Send/MPI_Recv`).
2. Построить графики ускорения и эффективности для числа процессов от 1 до 28.

## **Решение**

В решении используется явная разностная схема: температура покоординатно
хранится в двух массивах, содержащих её распределение в момент `n` и `n + 1`
соответсвенно. Начальные условия: $u(x, 0) = f(x) = 0$.

Число разбиений по координате `M` делим на требуемое количество процессов `size`
равномерно и передаем каждому процессу его индексы подсчета. `i`-ый процесс
производит параллельные вычисления между `i`-ым левым индексом и `i + 1`-ым
(не включая). Так как для вычисления значения в `m`-ом элементе требуется
значение `m, m - 1, m + 1` элементов, то для подсчета краевых значений
происходит обмен краевыми узлами. 

После конечной итерации значения, подсчитываемые каждым процессом, передаются с
помощью `MPI_Send` 0-ому процессу, который с помощью `MPI_Recv` собирает
все полученные значения, получая требуемое распределение температуры.

**Магические числа**:
1. Левый индекс `0`-го процесса равен `1`, правый `size - 1`-го --- `M - 1`.
2. `Time < 0` смоделировать нельзя.
3. При `M < 2` метод не сходится.
4. При `M < size` задача становится нелогичной.
5. Шаг по времени $\tau = 0,3 \text{(число Куранта)} \cdot h$ --- шаг по времени.

Исполняемый файл `solution.c` вычисляет и выводит распределение температуры в 
стержне в указанный момент времени. Необходимые входные параметры:
 - `Time` --- момент времени, в который требуется узнать распределение температуры;
 - `M` --- число разбиения координаты стержня;
 - `size` --- необходимое количество процессов.

Запуск: `mpicc -O3 solution.c && mpirun -np size ./a.out Time M`

Исполняемый файл `time.c` вычисляет и выводит время работы программы.
Необходимые входные параметры:
 - `Time` --- момент времени, в который требуется узнать распределение температуры;
 - `M` --- число разбиения координаты стержня;
 - `size` --- необходимое количество процессов;
 - 
Запуск: `mpicc -O3 time.c && mpirun -np size ./a.out Time M`

## **Запуск на учебном кластере**

Перед запуском программы на учебном кластере ее требуется предварительно
скомпилировать `mpicc -O3 time.c`. Скрипт `job.sh` для учебного кластера кластера:
```
#!/bin/bash
#PBS -l walltime=00:10:00,nodes=7:ppn=4
#PBS -N s77103
#PBS -q batch
cd $PBS_O_WORKDIR
for((i = 1; i <= 28; i++))
do
mpirun —hostfile $PBS_NODEFILE -np $i ./test 50000 0.000001
done
```
Постановка задачи в очередь --- `qsub job.sh`. Проверка состояния задачи --- `qstat`.

## **Запуск на персональном компьютере либо в Unix оболочке**

**Важно**: сборочный скрипт `build.sh` не работает на учебном кластере.
1. `./build.sh Time M`
2. Или запустите в своей командной оболочке Unix:

```
mpicc -Wall -Wextra -pedantic -O3 -Wshadow -Wformat=2 -Wfloat-equal -Wconversion \
-Wcast-qual -Wcast-align -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC \
-fsanitize=undefined -fno-sanitize-recover=all -fstack-protector -o test time.c
mpirun -np size ./test Time M
```

### **Результат**

Скрипт `build.sh` с параметрами `Time M`:
 - скомпилирует и запустит исполняемый файл `time.c` на требуемом кол-ве процессов;
 - результат запишет в файл `./res/data.txt`, предварительно его очистив;
 - с помощью исполняемого файла `data.c` создаст два дополнительных файла
`acceleration.txt` и `efficiency.txt`, в которых будут записаны ускорение и
эффективность соответственно
 - с помощью `gnuplot` построит требуемые графики и сохранит их в папкe `res`