# **Одномерное уравнение теплопроводности**

Задача: решить одномерное уравнение теплопроводности при заданных граничных условиях и начальном распределении температуры `f(x)`. 

Представим, что значально температура в стержне длины `L` была распределена по закону `f(x)`. Далее к его краям приложили два нагретых бруска с температурами `Temperature_1` и `Temperature_2` соответственно. По закону теплопроводности Фурье начал происходить теплообмен стержня с брусками. 

Входные параметры:
1. Момент времени `Time`, в который требуется узнать распределение температуры.
2. Число разбиения длины стержня `M`.

Результат: распределение температуры в стержне в заданный момент времени.

### **Требования**
1. Распараллелить программу, используя среду MPI (обязательно использовать вызовы `MPI_Send/MPI_Recv`).
2. Построить графики ускорения и эффективности для числа процессов от 1 до 28.

## **Решение**

В решении используется явная разностная схема, температура покоординатно хранить в двух массивах, содержащих её распределение в момент `n` и `n + 1` соответсвенно. `u(x, 0) = f(x) = 0`.

Число разбиений по координате `M` делим на требуемое количество процессов `size` равномерно и передаем каждому процессу его индексы подсчета. `i`-ый процесс производит параллельные вычисления между `i`-ым левым индексом и `i - 1`-ым (не включая). Так как для вычисления значения в `m`-ом элементе требуется значение `m, m - 1, m + 1` элементов, то для подсчета краевых значений происходит обмен краевыми узлами. 

После конечной итерации значения подсчитываемые каждым процессом передаются с помощью ```MPI_Send``` 0-ому процессу, который с помощью ```MPI_Recv``` собирает все полученные значения, получая требуемое распределение температуры.

**Особенности работы программы (костыли)**:
1. У `0`-го процесса левый индекс всегда равен `1`, а у `size - 1`-го правый индекс всегда равен `M - 1`.
2. Отрицательное время `(Time < 0)` смоделировать нельзя
3. При `M < 2` метод не сойдется.
4. При `M < size` задача становится нелогичной.
5. Шаг по времени `tau = 0,3 (число Куранта) * h` (шаг по времени).

Файл исходного кода `heat.c` выводит время работы программы для указанного количества процессов.

## **Запуск**

**Важно**: сборочные скрипты `build.sh, build_graphics.sh` не будут работать на учебном кластере. Можете попробовать запустить их на вашем ПК/ноутбуке.
1. `./build.sh время число_разбиений_по_координате`
2. Или запустите в своей командной оболочке Unix:

```
mpicc -Wall -Wextra -pedantic -O3 -Wshadow -Wformat=2 -Wfloat-equal -Wconversion -Wcast-qual \
-Wcast-align -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -fsanitize=undefined \
-fno-sanitize-recover=all -fstack-protector -o test heat.c -lm
mpirun -np number_of_processes ./test time partition_of_the_grid
```

Скрипт для общего кластера смотрите на сайте lms.mipt.ru в вкладке "Параллельное программирование". В методичке "Учебный кластер" описан процесс поставки задачи в очередь и исполнения на учебном кластере.

## **Результат**

Все результаты находятся в папке `res`. В файле `data.txt` первой колонкой записано количество процессов, второй — среднее время их выполнения при выборке в 1000 последовательных запусков. 

Запускаем скрипт для построения графиков `build_graphics.sh`. Он последовательно скомпилирует файл `data.c`, который создаст два файла: в `acceleration.txt` второй колонкой записаны ускорения процессов, в `efficiency.txt` — эффективности и запустит `gnuplot`, который отрисует требуемые графики